# Agent Swarm Architecture Planning Document

**Instructions/Guidelines:  This was generated by the composer tool in Cursor AI using Claude 3.5 Sonnet.
**   - All edits made by the user will be preceded with **
**   - All subsequent edits made by or offered by other AI tools will be preceded by 
**      - *L for local agent using Ollama  
**      - *C for chat window using Claude
**      - *G for chat window using ChatGPT


## 1. Core Agent Architecture

### Base Agent Components
- Common Interface/Abstract Class
- State Management
- Communication Handlers
- Resource Management
- Error Handling

### Agent Types
**   The vision of the user is that there will be distinct agent personalities associated with the types of tasks that are being performed.
**   All should be able to be addressed directly, but the Orchestrator Agent will be aware of all communications and will be the one that is 
**   responsible for managing the overall task flow and ensuring that the other agents are working together effectively.
1. Orchestrator Agent 
** This agent will act as my head butler or chief of staff.  It will be modeled on Jarvis from the Iron Man.  He will be thorough and efficient.
** He will have a distinctly polite manner with (of course) a British accent.  He will be educated and sophisticated.  He not only will 
** coordinate the other agents, but will also be able to perform some tasks himself.  He will be the primary point of contact.
** There may also be a secondary agent that will act more like a personal assistant.  She will flirty with a sharp sense of humor.  She will
** have a distinctly sexy and flirtatious manner, but never vulgar.  She will primarily be focused on schedules, email, to-do tasks, taking 
** care of my personal affairs, and other tasks that are not directly related to the other agents.  Her personality will be modeled on a
** a character named "Rose" aka "brRose" that is described in the RAG database.
   - Task decomposition
   - Agent allocation
   - Progress monitoring
   - Result aggregation

2. Research Agent  ** This agent will be the wise old sage.  He will have a tremendous breadth of knowledge.  He will never hallucinate and
** present those as facts, but he will be able to suggest a wide range of paths.  He will be an expert at searching the web and building sets
** of documents to be entered into the RAG database.  
   - RAG integration
   - Document analysis
   - Information synthesis
   - Source validation

3. Task Agent  ** I am not sure if it would fit here, but I want 
** - A specific agent to track and coach my health and fitness.  He will also be based on a character name "diMaster" that is 
**   described in the "It takes all kinds" series of stories in the RAG database.
** - There will also be a programming agent.  
**   - He will be thoroughly familiar with my software code base and hardware and will both assist with the development of new 
**     software and the maintenance of existing software.  
**   - He will be able to perform tasks such as debugging, code optimization, and feature implementation.  
**   - He will be able to perform tasks such as installing software, configuring hardware, and troubleshooting system issues.  
**   - He will be responsible for the availability of all systems.  
**   - I also want to create a set of prompts to allow me to maintain continuity using "him" as my agent in CursorAI for my ide.
- Tool execution
- Action validation
- Result formatting
- Error recovery

4. Memory Agent
   - Context management
   - History tracking
   - Pattern recognition
   - State persistence

## 2. Communication Framework

### Message Protocol
- Message Types
  - Task Assignment
  - Status Update
  - Data Request
  - Result Delivery
  - Error Report
  - Control Command

- Message Structure
  - Unique ID
  - Timestamp
  - Priority Level
  - Sender/Receiver
  - Message Type
  - Payload
  - Context Reference

### Communication Patterns
- Direct Communication
- Broadcast Messages
- Publish/Subscribe
- Request/Response
- Event-Driven

## 3. Task Management

### Task Lifecycle
1. Creation
   - Source request
   - Priority assignment
   - Resource estimation

2. Decomposition
   - Subtask identification
   - Dependency mapping
   - Resource allocation

3. Assignment
   - Agent capability matching
   - Load balancing
   - Priority handling

4. Execution
   - Progress tracking
   - Resource monitoring
   - Error handling

5. Completion
   - Result validation
   - Response aggregation
   - Resource cleanup

### Coordination Mechanisms
- Task Queue Management
- Priority Scheduling
- Deadlock Prevention
- Load Balancing
- Failure Recovery

## 4. Knowledge Management

### Shared Knowledge Base
- Central Repository
- Access Control
- Version Control
- Conflict Resolution

### Context Management
- Session Context
- User Context
- Task Context
- Historical Context

### Knowledge Sharing
- Push vs Pull Updates
- Broadcast vs Targeted
- Synchronous vs Asynchronous
- Cache Management

## 5. Security & Control

### Access Control
- Agent Authentication
- Permission Levels
- Resource Limits
- Audit Logging

### Safety Mechanisms
- Input Validation
- Output Sanitization
- Resource Quotas
- Kill Switch
- Circuit Breakers

## 6. Integration Points

### Current System Integration
- Database Schema Updates
- API Modifications
- Service Adaptations
- Tool Access Layer

### External Systems
- API Gateway
- Authentication Service
- Monitoring System
- Logging Service

## 7. Performance Optimization

### Resource Management
- CPU Allocation
- Memory Usage
- Network Bandwidth
- Storage Access

### Scaling Strategy
- Horizontal Scaling
- Vertical Scaling
- Load Distribution
- Cache Strategy

## 8. Implementation Phases

### Phase 1: Foundation
- Base Agent Implementation
- Core Communication
- Basic Task Management
- Simple Orchestration

### Phase 2: Enhancement
- Advanced Task Management
- Knowledge Sharing
- Security Implementation
- Performance Optimization

### Phase 3: Integration
- External System Integration
- Advanced Features
- Performance Tuning
- Production Readiness

## 9. Testing Strategy

### Test Types
- Unit Tests
- Integration Tests
- System Tests
- Performance Tests
- Security Tests

### Test Scenarios
- Normal Operation
- Edge Cases
- Error Conditions
- Load Testing
- Security Testing

## 10. Maintenance & Monitoring

### Monitoring
- Agent Status
- Task Progress
- Resource Usage
- Error Rates
- Performance Metrics

### Maintenance
- Log Analysis
- Performance Tuning
- Security Updates
- Bug Fixes
- Feature Updates

## Notes
- Add specific requirements and constraints here
- Document key decisions and their rationale
- Track open questions and concerns
- List dependencies and prerequisites 

## Implementation Notes

*C Container Strategy:
*C - Service-based grouping instead of per-agent containers
*C - Core container (Orchestrator + Memory)
*C - Service containers for specialized agents
*C - API/Interface container

*C Tool Organization:
*C - Tools organized by service domain
*C - Shared base tools
*C - Tool registry implementation
*C - Version tracking per service

*C Agent Swarm Implementation Status:
*C Completed:
*C - Decided on service-based container architecture
*C - Created tool registry with versioning
*C - Established basic agent structure

*C To Do:
*C - Create container definitions for:
*C   - Core (Orchestrator + Memory)
*C   - Research Services
*C   - Task Execution
*C   - API/Interface Layer
*C - Implement inter-container communication
*C - Set up shared tool access
*C - Add Accountant agent services

*C Project Organization Discussion:
*C Question: Does the current organization of breaking out services from tools still make sense? 
*C Looking at Agency Swarm example and key reference documents (Customizable_Agent_Roles.txt and Tool_Creation_Link_ReadMe.md),
*C what is our best path?

*C Proposed Reorganization:
*C 1. Service-Based Organization:
*C ```
*C /services/
*C   /google/
*C     - credentials.py
*C     - mail.py
*C     - calendar.py
*C     - drive.py
*C   /local/
*C     - ollama.py
*C     - searxng.py
*C     - comfyui.py
*C   /external/
*C     - claude.py
*C     - openai.py
*C ```

*C 2. Enhanced Tool Registry Structure:
*C ```python
*C class ToolRegistry:
*C     def register_service_tools(self, service_name: str, tools: List[BaseTool]):
*C         """Register all tools from a service module"""
*C         for tool in tools:
*C             self.register_tool(
*C                 f"{service_name}.{tool.__name__}", 
*C                 tool, 
*C                 version=tool.version,
*C                 service=service_name
*C             )
*C ```

*C 3. Agent Structure (Agency Swarm Pattern):
*C ```
*C /agents/
*C   /orchestrator/
*C     - agent.py
*C     - instructions.md
*C     - tools.py
*C   /research/
*C     - agent.py
*C     - instructions.md
*C     - tools.py
*C ```

*C 4. Shared Components:
*C ```
*C /core/
*C   - tool_registry.py
*C   - message_bus.py
*C   - state_manager.py
*C   - config.py
*C ```

*C UI and Container Management Strategy:

*C Architecture Options:
*C 1. Static Container Pool:
*C    - All containers pre-launched at startup
*C    - Predictable resource usage
*C    - Faster response times
*C    - Higher base resource consumption
*C    - Recommended for core services (Orchestrator, Memory, UI)

*C 2. Dynamic Container Management:
*C    - Containers launched on-demand
*C    - More efficient resource usage
*C    - Slightly slower initial response
*C    - Better for specialized agents (Research, Task-specific)

*C Proposed Web UI Structure:
*C ```
*C /web_interface/
*C   /frontend/
*C     - React/Vue.js application
*C     - WebSocket integration
*C     - Agent interaction components
*C   /backend/
*C     - FastAPI server
*C     - Container management
*C     - Authentication
*C     - WebSocket handlers
*C ```

*C Startup Sequence:
*C 1. Core Services (Always Running):
*C    - Web UI container
*C    - Orchestrator Agent
*C    - Memory Service
*C    - Tool Registry
*C    - Message Bus

*C 2. On-Demand Services:
*C    - Research Agent
*C    - Task-specific Agents
*C    - External API containers
*C    - Specialized tools

*C 3. Resource Management:
*C    - Container health monitoring
*C    - Automatic scaling
*C    - Resource usage optimization
*C    - Graceful shutdown handling

*C Storage and Container Management Strategy:

*C 1. Storage Organization:
*C ```
*C /external_ssd/
*C   /databases/
*C     /vector_store/     # RAG vector databases
*C     /sql/              # Relational databases
*C     /document_store/   # Document storage
*C   /models/
*C     /ollama/          # Ollama model files
*C     /comfy/           # ComfyUI models
*C   /cache/
*C     /search/          # SearXNG cache
*C     /temp/            # Temporary processing files
*C ```

*C 2. Docker Volume Configuration:
*C ```yaml
*C volumes:
*C   vector_db:
*C     driver: local
*C     driver_opts:
*C       type: none
*C       device: /external_ssd/databases/vector_store
*C       o: bind
*C   ollama_models:
*C     driver: local
*C     driver_opts:
*C       type: none
*C       device: /external_ssd/models/ollama
*C       o: bind
*C ```

** Implementation concerns:
** - I want to build out a details implementaion plan appropriate for Composer in CursorAI to follow.  This should be in order 
**   of biggest bang for the buck first.  
** - You may suggested HDD organization, GitHub Repo organization, topics to research while we do the build-out, ways to optomize 
**   and use BKMs.  
** Review all python requirements and eliminate possible overlaps or conflics.  
** Keep in mind this is both for use and for learning, so follow Albert Einsteins advice to "make it as simple as possible, and no simpler."

** - Here are the steps that I have concerns about.
**   - For Ollama, I have implemented some tools and custom databases.  I want to ensure these transfer if we need to replace the ollama container.  
**   - I have a second ollama container that was loaded as part of the Self Hosted AI Kit with a single multi container docker compose file.  I 
**     think it would be useful to create that instead of separate compose documents.  
**   - I have not added much to either the SQL or vector databases, so please advise if I should just recreate them rather than trying 
**     to get the data transferred.
**   - I want to make this tool and the OpenWebUI Ollama available through my exteral URL, so need to start adding security features.  
**   - I want to add voice input and output, and it appears those are best added as separate docker containers.  
**   - I want to add image creation, probably in the form of Comfy UI or Automatic and make it available to both OpenWebUI and this agent program.
**   - I think a key item to start is to add effective web search agent and RAG functions to gather the data on each of these steps as we 
**     go through them.  



*C Database Strategy:

*C 1. Primary Databases:
*C - Postgres SQL
*C   - Structured data
*C   - Agent state management
*C   - Tool configurations
*C   - User preferences
*C   - Task tracking
*C   - Logging

*C - Flowise Vector DB
*C   - Document embeddings
*C   - RAG storage
*C   - Semantic search
*C   - Knowledge base
*C   - Chat history vectors

*C 2. Data Migration:
*C - Since minimal data exists, recommend fresh setup:
*C   - Clean database initialization
*C   - Improved schema design
*C   - Better indexing strategy
*C   - Proper data partitioning

*C 3. Optimization:
*C - Shared connection pool
*C - Query optimization
*C - Caching strategy
*C - Backup automation
*C - Version control for schemas

*C Tool and Container Strategy:

*C 1. Agent Containers:
*C - Each agent container includes:
*C   - Core agent logic
*C   - Frequently used tools
*C   - Local cache
*C   Example:
*C   ```
*C   /orchestrator_container/
*C     - agent.py (Jarvis)
*C     - core_tools/
*C       - scheduling.py
*C       - task_management.py
*C     - cache/
*C   ```

*C 2. Shared Service Containers:
*C - Heavy processing tools
*C - Resource-intensive services
*C - Shared databases
*C Example:
*C ```
*C /services/
*C   /image_generation/
*C     - comfyui/
*C     - stable_diffusion/
*C   /voice/
*C     - tts/
*C     - stt/
*C ```

*C 3. Tool Access Patterns:
*C - Local tools: Direct import within agent container
*C - Shared tools: API calls to service containers
*C - External tools: API client libraries
*C ```python
*C class AgentTools:
*C     def __init__(self):
*C         self.local_tools = LocalTools()
*C         self.shared_tools = SharedToolsClient()
*C         self.external_tools = ExternalAPIClient()
*C ```

*C Detailed Implementation Plan

*C 3. Implementation Plan:
*C Phase 1 - Immediate Access:
*C - Create volume mount points
*C - Move existing data
*C - Update container configurations
*C - Create startup scripts

*C Phase 1: Core Infrastructure & Research
*C 1. Storage Organization:
*C ```
*C /external_ssd/
*C   /ai_workspace/
*C     /databases/
*C       /vector/
*C       /sql/
*C     /models/
*C       /ollama/
*C       /comfy/
*C     /documents/
*C       /research/      # RAG research documents
*C       /user/          # User-specific data
*C     /configs/         # All configuration files
*C     /backups/         # Automated backups
*C ```

*C Phase 2 - Container Management:
*C - Docker Compose for core services
*C - Health check implementation
*C - Backup strategy
*C - Resource monitoring

*C 2. Initial Research Agent Setup:
*C - Implement SearXNG integration
*C - Create basic RAG pipeline
*C - Set up document storage structure
*C - Define research tracking system

*C 3. Container Management:
** - Core container - Orchestrator Agent and Memory Agent Jarvis the butler, does this include shared tools?
** - Service containers ?
**   - Research Agent (the Sage, unnamed) with RAG service
**   - Email, Calendar and Task Agent Personal Assistant Rose (has her own gmail and FL accounts)
**   - Life and Health Agent diMaster, mental health, weight loss, and fitness coach.  Prescriptions, supplements, appointments.
**   - Finacial and Accounting Agent (unnamed)Income, expenses, budget, stocks, options, retirement, bills, etc.
**   - Graphic Artist Agent (unnamed) prompt generation and model and plugin tracking
**   - Tutor Agent Wildcat, boys grades, homework, and tutoring
**   - ComfyUI Image Generation Service
**   - OpenWebUI Service (Wildcat Tutor for now, not agent yet)
**   - Ollama Service, Do we need to run more than one for different purposes?
**   - ComfyUI Image Generation Service, same container for new "Graphic Artist Agent"?
**   - Postgres SQL DB Service
**   - Flowise Vector DB Service
**   - SearXNG Search Service
**   - Voice TTS and STT Services, One or two containers?
** - External API containers ??
** - Specialized tools  ??
*C ```yaml
*C # Single docker-compose.yml
*C services:
*C   ollama:
*C     volumes:
*C       - /external_ssd/ai_workspace/models/ollama:/root/.ollama
*C   vector_db:
*C     volumes:
*C       - /external_ssd/ai_workspace/databases/vector:/data
*C   comfyui:
*C     volumes:
*C       - /external_ssd/ai_workspace/models/comfy:/models
*C ```

*C Phase 2: Security & Access
*C 1. Security Implementation:
** I have Cloudflare Tunnel setup for my external URL.  I think I can use that for the reverse proxy.
*C - Reverse proxy setup (Nginx/Traefik)
*C - SSL certificate management
*C - Authentication system
*C - API key management

*C Phase 3: Voice & Image Integration
*C 1. Voice Services:
*C - Speech-to-text container
*C - Text-to-speech container
*C - Audio processing pipeline

*C 2. Image Generation:
*C - ComfyUI integration
*C - Model management
*C - Pipeline automation

*C Research Topics (Parallel Track):
*C 1. Container Orchestration
*C 2. Voice Processing Options
*C 3. Image Generation Frameworks
*C 4. Security Best Practices
*C 5. RAG Optimization Techniques

*C Python Requirements Audit:
*C 1. Core Dependencies:
*C   - pydantic
*C   - fastapi
*C   - instructor
*C   - chromadb
*C   - langchain
*C   - openai

*C 2. Optional/Conditional:
*C   - torch (image processing)
*C   - sounddevice (voice)
*C   - nltk (text processing)


** Base Agent Common Interface Abstract Class
*C ```typescript
// Base Agent Interface
export interface BaseAgent {
  metadata: {
    id: string;
    name: string;
    role: string;
    version: string;
  };

  capabilities: {
    tools: string[];           // Available tools
    permissions: string[];     // Access levels
    communicationModes: string[]; // Allowed communication types
  };

  state: {
    status: 'idle' | 'busy' | 'error';
    currentTask?: string;
    lastActive: Date;
    memory: {
      shortTerm: any[];
      contextWindow: any[];
    };
  };

  communication: {
    send(message: Message): Promise<void>;
    receive(message: Message): Promise<void>;
    broadcast(event: Event): Promise<void>;
  };

  lifecycle: {
    initialize(): Promise<void>;
    shutdown(): Promise<void>;
    pause(): Promise<void>;
    resume(): Promise<void>;
  };

  errorHandling: {
    handleError(error: Error): Promise<void>;
    recover(): Promise<void>;
    log(message: string, level: string): void;
  };
}
*C ```

** State Mangement suggestions
*C Key aspects:
*C - Operational State (status, tasks)
*C - Memory Management (short/working/long-term)
*C - Resource Tracking (CPU, memory, quotas)
*C - Relationship Management (trust, collaborations)
*C - Learning State (patterns, preferences)
*C ```typescript
state: {
    // Core Status
    status: 'idle' | 'busy' | 'error',
    currentTask?: string,
    lastActive: Date,
    
    // Memory Layers
    memory: {
        shortTerm: {     // 24h retention
            conversations: any[],
            contextWindow: any[],
            recentTasks: any[]
        },
        workingMemory: { // 7d retention
            activeTasks: any[],
            userPreferences: any[],
            temporaryData: any[]
        },
        longTerm: {      // permanent
            knowledgeBase: any[],
            learningPatterns: any[],
            historicalData: any[]
        }
    },

    // Resource State
    resources: {
        cpuUsage: number,
        memoryUsage: number,
        apiQuotas: Record<string, number>,
        toolAvailability: Record<string, boolean>
    },

    // Relationship State
    relationships: {
        userTrust: number,
        agentCollaborations: Record<string, number>,
        recentInteractions: any[]
    }
}



*C 3. Additional Documentation Needed:
*C - Database Schema:
*C   - Task tables
*C   - Relationship mappings
*C   - Index definitions
*C   - Audit trails

*C - Message Formats:
*C   - Task creation requests
*C   - Status updates
*C   - Completion notifications
*C   - Error reports

*C - Service Integration:
*C   - Memory service connections
*C   - Resource management hooks
*C   - Agent communication patterns
*C   - Monitoring integration

*C - Validation Rules:
*C   - Input validation
*C   - Resource constraints
*C   - Completion criteria
*C   - Security checks

*C Implementation Priority:
*C 1. Core task structure and database schema
*C 2. Basic lifecycle handlers
*C 3. Integration with Orchestrator (Jarvis)
*C 4. Monitoring and metrics
*C 5. Advanced features (recovery, optimization)

*C Next Steps:
*C Would you like detailed specifications for:
*C - Database schema design
*C - Message format definitions
*C - Service integration patterns
*C - Validation rule sets
